\documentclass[a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{tikz}
\usepackage{scalefnt}
\usepackage{microtype}

\parindent 8pt
\parskip 2pt

\lstset{tabsize=2, basicstyle=\small, breaklines=true, numbers=left, language=c++}

\title{libea 0.2 - A brief introduction}
\author{Sebastian Fedrau}
\date{February, 2015}

\begin{document}

\maketitle

\newpage

\section{Introduction}

\textsc{libea} is a template based library written in C++14. The purpose of this software is to provide an extensible and reliable framework for writing evolutionary algorithms.

\section{Building libea}

To build \textsc{libea} scons\footnote{\url{http://www.scons.org/}} is required. The library can be compiled and installed with the following commands:

\begin{lstlisting}[language=bash, numbers=none]
# scons libea
# sudo scons install
\end{lstlisting}

After the installation you may want to build the test suite. Please note that this step requires the CppUnit\footnote{\url{http://freedesktop.org/wiki/Software/cppunit/}} framework:

\begin{lstlisting}[language=bash, numbers=none]
# scons test-suite
\end{lstlisting}

If you want to generate the source code documentation please ensure Doxygen\footnote{\url{http://www.stack.nl/~dimitri/doxygen/}} is installed on your system and type in the following command:

\begin{lstlisting}[language=bash, numbers=none]
# scons doc
\end{lstlisting}

This documentation can be build with

\begin{lstlisting}[language=bash, numbers=none]
# scons pdf
\end{lstlisting}

\section{The framework}

\subsection{A quick overview}

In \textsc{libea} individuals are represented in \textit{sequences}. Theoretically any data type large enough to store the genotype of an individual is a valid sequence type. A group of sequences is called \textit{population}.

To modify a sequence or evaluate its fitness a corresponding \textit{genome base class} inherited from \textit{ea::AGenomeBase} is required. Figure~\ref{fig:overview} illustrates this concept.

\begin{figure}[h]
\caption{sequences and corresponding genome base class}
\label{fig:overview}
{\scalefont{0.6}
\include{img/overview}
}
\end{figure}

\textsc{libea} offers the genome base class templates \textit{ea::PGenomeBase} and \textit{ea::CPGenomeBase} with the corresponding sequence types \textit{ea::Sequence} and \textit{ea::CSequence}. Any data type with a valid copy constructor is a supported gene type. There are already type aliases for many primitive data types available in \textsc{libea} (see table~\ref{tab:genome-base-classes-and-sequences}).

\begin{table}
\caption{genome base classes and corresponding sequence types offered by \textsc{libea}}
\label{tab:genome-base-classes-and-sequences}
\begin{tabular}{|l|l|l|}
\hline
\textsc{genome base class} & \textsc{corresponding sequence type} & \textsc{gene type} \\
\hline
ea::PGenomeBase\textless T\textgreater & ea::Sequence\textless T\textgreater & T \\
ea::Int32PenomeBase & ea::Sequence\textless int32\_t\textgreater & int32\_t \\
ea::UInt32PGenomeBase & ea::Sequence\textless uint32\_t\textgreater & uint32\_t \\
ea::BinaryPGenomeBase & ea::Sequence\textless bool\textgreater & bool \\
ea::DoublePGenomeBase & ea::Sequence\textless double\textgreater & double \\
ea::StringPGenomeBase & ea::Sequence\textless std::string\textgreater & std::string \\
\hline
ea::CPGenomeBase\textless T\textgreater & ea::CSequence\textless T\textgreater & T \\
ea::Int32CPenomeBase & ea::CSequence\textless int32\_t\textgreater & int32\_t \\
ea::UInt32CPGenomeBase & ea::CSequence\textless uint32\_t\textgreater & uint32\_t \\
ea::BinaryCPGenomeBase & ea::CSequence\textless bool\textgreater & bool \\
ea::DoubleCPGenomeBase & ea::CSequence\textless double\textgreater & double \\
ea::StringCPGenomeBase & ea::CSequence\textless std::string\textgreater & std::string \\
\hline
\end{tabular}
\end{table}

The two offered base class templates are optimized for different use-cases. As shown in listing~\ref{lst:sequence} the \textit{ea::Sequence} structure has only two fields which are used to store the length of a sequence and its genes. Hence this kind of sequence is preferable if the application's memory footprint is critical.

In comparison the \textit{ea::CSequence} structure has three additional fields. They are used to cache the evaluated fitness value and the hash of an individual (see listing~\ref{lst:csequence}). In general this sequence type is a better choice because the performance benefit might out weight the drawback of memory consumption.

The fields of both structures should \textbf{never be accessed directly}. \textsc{libea} provides the functions \textit{ea::sequence\_len()} and \textit{ea::sequence\_get()} for reading genes from a sequence.

\begin{lstlisting}[caption=Sequence template declaration, label=lst:sequence]
template<typename TGene>
struct Sequence
{
	/*! Datatype of stored genes. */
	typedef TGene gene_type;

	/*! Number of stored genes. */
	uint16_t len;
	/*! Dynamic array holding genes. */
	TGene* genes;
};
\end{lstlisting}

\begin{lstlisting}[caption=CSequence template declaration, label=lst:csequence]
template<typename TGene>
struct CSequence : Sequence<TGene>
{
	/*! Flags. */
	uint8_t flags;
	/*! Cached fitness value. */
	float fitness;
	/*! Cached hash value. */
	size_t hash;
};
\end{lstlisting}

\subsection{Core features}

\subsection{Working with sequences}

Listing~\ref{lst:core-functions} demonstrates some basic functions of \textsc{libea}. An individual represented in a sequence of integers is created (ll. 44-50) and copied (l. 62). The sequences are compared before and after modifying the second individual (ll. 67-75).

To access the genes and evaluate the fitness a genome base class is declared (l. 22). The template parameters specify the gene type and fitness function (ll. 5-19).

\begin{lstinputlisting}[caption=core functions,label=lst:core-functions]{examples/00-core-functions.cpp}
\end{lstinputlisting}

\subsection{Factories \& output adapters}

\textsc{libea} offers the \textit{ea::AFactory} base class as an option to create populations. Listing~\ref{lst:factory} shows how to create sequences of ten random integers using a custom factory (ll. 30-51). The values are generated with a random number generator (ll. 35-46).

The individuals are written to an \textit{ea::OutputAdapter} (ll. 74-77). At the current stage \textsc{libea} only provides an adapter for STL containers like \textit{std::vector}, but new adapters can be added easily by implementing the \textit{ea::IOutputAdapter} interface. To create an adapter use the \textit{ea::make\_output\_adapter()} function.

\begin{lstinputlisting}[caption=custom factory,label=lst:factory]{examples/01-factory.cpp}
\end{lstinputlisting}

\subsection{Selection operators}

Selection operators have to implement the \textit{ea::IIndexSelection} interface (see listing~\ref{lst:iindexselection}). Instead of copying the selected genomes to an \textit{ea::OutputAdapter} only the indexes are written. Access to the parent individuals is given through an adapter implementing the \textit{ea::IInputAdapter} interface. Input adapters can be created for all STL containers providing random access iterators with the \textit{ea::make\_input\_adapter()} function.

\begin{lstlisting}[caption=IIndexSelection,label=lst:iindexselection]
template<typename TGenomeBase>
class IIndexSelection
{
	public:
		typedef typename TGenomeBase::sequence_type sequence_type;

		~IIndexSelection() {}

		virtual void select(IInputAdapter<sequence_type>& input, const uint32_t count, IOutputAdapter<uint32_t>& output) = 0;
};
\end{lstlisting}

Listing~\ref{lst:selection-example} creates a population with ten random sequences (ll. 43-58). Then five individuals are selected using the tournament selection operator (ll. 72-82).

\begin{lstinputlisting}[caption=selection operators,label=lst:selection-example]{examples/02-selection.cpp}
\end{lstinputlisting}

\subsection{Crossover operators}

Crossover operators are inherited from \textit{ea::ACrossover} and have to override the \textit{crossover()} method (see listing~\ref{lst:acrossover}). 

\begin{lstlisting}[caption=ACrossover,label=lst:acrossover]
template<typename TGenomeBase>
class ACrossover
{
	public:
		typedef typename TGenomeBase::sequence_type sequence_type;

		~ACrossover() {}

		virtual uint32_t crossover(const sequence_type& a, const sequence_type& b, IOutputAdapter<sequence_type>& output) = 0;
};
\end{lstlisting}

Crossover operators create at least one child sequence from two parent individuals. The \textit{crossover()} method returns the number of child sequences written to the given output adapter. Listing~\ref{lst:crossover-example} shows an example.

In the example two parent individuals are created (ll. 41-42). Then two children are generated using a cycle crossover operator (ll. 51-55).

\begin{lstinputlisting}[caption=crossover operators,label=lst:crossover-example]{examples/03-crossover.cpp}
\end{lstinputlisting}

\subsection{Mutation operators}

Mutation operators are inherited from \textit{ea::AMutation} and have to override the \textit{create\_child()} method (see listing~\ref{lst:amutation}). 

\begin{lstlisting}[caption=AMutation,label=lst:amutation]
template<class TGenomeBase>
class AMutation
{
	public:
		typedef typename TGenomeBase::sequence_type sequence_type;

		virtual ~AMutation() {};

		virtual void mutate(sequence_type& sequence) = 0;

		sequence_type create_child(const sequence_type& sequence)
		{
			static TGenomeBase base;

			sequence_type m = base.copy(sequence);
			mutate(m);

			return m;
		}
};
\end{lstlisting}

In listing~\ref{lst:mutation-example} a parent individual is created (ll. 43-48) and mutated in-place (l. 55). Afterwards an inverted child sequence is generated (ll. 59-61).

\begin{lstinputlisting}[caption=mutation operators,label=lst:mutation-example]{examples/04-mutation.cpp}
\end{lstinputlisting}

\subsection{Processing operator pipelines}

The \textit{ea::Pipeline} namespace provides a framework to connect and process multiple genetic operators.

\textsc{libea} processes operators by connecting elements to a pipeline. Pipeline elements read sequences from a source and write the processed data to a sink. Each element has to implement the \textit{ea::Pipeline::IElelement} interface. \textsc{libea} offers a corresponding pipeline element for all operator types.

A functor implementing the \textit{ea::Pipeline::ITerminator} is executed after the last pipeline element has been processed to decide if the process should be repeated (see figure~\ref{fig:pipeline}).

\begin{figure}[h]
\caption{connecting pipeline elements}
\label{fig:pipeline}
{
\include{img/pipeline}
}
\end{figure}

\subsubsection*{SelectionElement}

The \textit{ea::Pipeline::SelectionElement} pipeline element reads sequences from a source population and writes selected elements to the sink. Elements are selected by an underlying \textit{ea::IIndexSelection} operator.

Creating a \textit{ea::Pipeline::SelectionElemenet} instance two template parameters have to be defined: the desired selection operator and a functor inherited from \textit{ea::Pipeline::ASelectionSize}. The functor is required to determine the number of sequences to select. \textsc{libea} already offers two functors:

\begin{itemize}
	\item \textbf{\textit{ea::libea::SourceDivisor}}: divides the size of the source population by template parameter \textit{N}
	\item \textbf{\textit{ea::libea::FixedSelectionSize}}: returns the template parameter \textit{N}
\end{itemize}

\subsubsection*{CrossoverElement}

The \textit{ea::Pipeline::CrossoverElement} pipeline element combines all sequences from a source population and produces children using the underlying \textit{ea::ACrossover} operator. Generated children are written to the sink.

\subsubsection*{MutationElement}

The \textit{ea::Pipeline::MutationElement} reads sequences from a source population and writes them to the sink. When writing the sequences are mutated with a definable probability \textit{P} using the underlying \textit{ea::AMutation} operator.

\subsubsection*{ITerminator}

Terminators have to implement the \textit{ea::Pipeline::ITerminator} interface (see listing~\ref{lst:iterminator}). The \textit{()} operator returns \textit{true} if the process should be terminated and has the following parameters:

\begin{itemize}
	\item \textbf{\textit{step}}: a counter incremented at the beginning of each iteration
	\item \textbf{\textit{first}}: an input adapter providing access to the \textit{initial} population
	\item \textbf{\textit{current}}: an input adapter providing access to the \textit{current} population
\end{itemize}

\textsc{libea} offers the \textit{ea::Pipeline::ForLoopInidicator} to repeat the pipeline process using \textit{step} as loop counter.

\begin{lstlisting}[caption=ITerminator,label=lst:iterminator]
		template<typename TGenomeBase>
		class ITerminator
		{
			public:
				virtual ~ITerminator() {}

				virtual bool operator()(const uint32_t step,
						       IInputAdapter<typename TGenomeBase::sequence_type>& first,
						       IInputAdapter<typename TGenomeBase::sequence_type>& current) = 0;
		};
\end{lstlisting}

\subsubsection*{Travelling saleman problem}

Listing~\ref{lst:pipeline-example} connects four genetic operators to find solutions for the popular travelling salesman problem.

A city is identified by an \textit{uint8\_t} (l. 11). A route is a sequence of cities (l. 12). Each city has a location which can be accessed by a \textit{std::map} (ll. 14-31). The fitness function returns the sum of the distances between the cities of a route (ll. 34-51).

The initial population consists of 100 random routes created with a factory class (ll. 57-82). The mean and median fitness values are displayed (ll. 94-102) before processing the pipeline.

The operators are connected by their corresponding pipeline elements. At the beginning of each iteration sequences are selected by tournament selection. Then the selected sequences are used to create new children using edge recombination. After selecting 50 child sequences by double tournament selection the result is mutated using single swap mutation. The process is repeated 100 times (ll. 107-126).

After processing the pipeline mean and median fitness values of the generated child population are displayed (ll. 128-131).

\begin{lstinputlisting}[caption=pipeline operators,label=lst:pipeline-example]{examples/05-pipeline.cpp}
\end{lstinputlisting}

\section{Summary}

As you have seen in this introduction \textsc{libea} provides a basic framework to write evolutionary algorithms in a reliable way. There are some standard operators available which can be used with different kind of genomes.

The library has been written just for fun and I hope you might find it useful. To have a more detailed look at \textsc{libea} you should generate the code documentation as described before in this document.
\end{document}
